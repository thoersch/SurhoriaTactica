<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Surhoria Tactica - Enhanced Map Editor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        #sidebar {
            width: 320px;
            background: #252525;
            padding: 20px;
            overflow-y: auto;
            border-right: 2px solid #333;
        }

        #main {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        #toolbar {
            background: #252525;
            padding: 15px 20px;
            border-bottom: 2px solid #333;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        #canvas-container {
            flex: 1;
            overflow: auto;
            background: #1a1a1a;
            position: relative;
        }

        canvas {
            display: block;
            cursor: crosshair;
            image-rendering: pixelated;
        }

        h2 {
            color: #4a9eff;
            margin-bottom: 15px;
            font-size: 18px;
        }

        h3 {
            color: #6ab0ff;
            margin: 20px 0 10px 0;
            font-size: 14px;
        }

        .section {
            margin-bottom: 25px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-size: 13px;
            color: #b0b0b0;
        }

        input[type="text"],
        input[type="number"],
        select,
        textarea {
            width: 100%;
            padding: 8px;
            background: #1a1a1a;
            border: 1px solid #444;
            color: #e0e0e0;
            border-radius: 4px;
            margin-bottom: 10px;
            font-size: 13px;
        }

        textarea {
            resize: vertical;
            min-height: 60px;
            font-family: 'Segoe UI', sans-serif;
        }

        input[type="text"]:focus,
        input[type="number"]:focus,
        select:focus,
        textarea:focus {
            outline: none;
            border-color: #4a9eff;
        }

        button {
            padding: 8px 16px;
            background: #4a9eff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
        }

        button:hover {
            background: #3a8eef;
        }

        button:active {
            background: #2a7edf;
        }

        button.danger {
            background: #e63946;
        }

        button.danger:hover {
            background: #d62839;
        }

        .tile-palette {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 15px;
        }

        .tile-button {
            padding: 12px 8px;
            background: #1a1a1a;
            border: 2px solid #444;
            cursor: pointer;
            font-size: 11px;
            text-align: center;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .tile-button:hover {
            border-color: #6ab0ff;
        }

        .tile-button.selected {
            border-color: #4a9eff;
            background: #2a4a6a;
        }

        .color-preview {
            width: 20px;
            height: 20px;
            display: inline-block;
            border: 1px solid #666;
            vertical-align: middle;
            margin-left: 8px;
            border-radius: 2px;
        }

        .info-text {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        #coordinates {
            background: #1a1a1a;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            color: #6ab0ff;
            font-family: monospace;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: #252525;
            padding: 30px;
            border-radius: 8px;
            max-width: 700px;
            max-height: 85vh;
            overflow-y: auto;
            border: 2px solid #444;
        }

        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: flex-end;
        }

        .list-item {
            background: #1a1a1a;
            padding: 12px;
            margin-bottom: 8px;
            border-radius: 4px;
            border: 1px solid #444;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .list-item-content {
            flex: 1;
        }

        .list-item button {
            padding: 4px 12px;
            font-size: 11px;
            margin-left: 8px;
        }

        .error {
            color: #ff6b6b;
            font-size: 12px;
            margin-top: 5px;
        }

        .success {
            color: #51cf66;
            font-size: 12px;
            margin-top: 5px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .object-marker {
            position: absolute;
            pointer-events: none;
            font-size: 16px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="sidebar">
        <h2>Map Properties</h2>
        
        <div class="section">
            <label>Map ID:</label>
            <input type="text" id="map-id" value="new_map">
            
            <label>Map Name:</label>
            <input type="text" id="map-name" value="New Map">
            
            <label>Width (tiles):</label>
            <input type="number" id="map-width" value="30" min="5" max="100">
            
            <label>Height (tiles):</label>
            <input type="number" id="map-height" value="20" min="5" max="100">
            
            <label>Tile Size (pixels):</label>
            <input type="number" id="tile-size" value="32" min="16" max="64">
            
            <button onclick="resizeMap()">Apply Size</button>
        </div>

        <h3>Tile Palette</h3>
        <div class="tile-palette" id="tile-palette"></div>

        <h3>Tools</h3>
        <div class="button-group">
            <button onclick="setTool('paint')">Paint</button>
            <button onclick="setTool('fill')">Fill</button>
            <button onclick="setTool('select')">Select & Move</button>
            <button onclick="setTool('spawn')">Set Spawn</button>
            <button onclick="setTool('object')">Place Object</button>
            <button onclick="setTool('zone')">Add Zone</button>
        </div>
        
        <div class="info-text" style="margin-top: 10px;">
            üí° Tip: Click on doors or objects to configure them!
        </div>

        <h3>Special Elements</h3>
        <div class="section">
            <button onclick="showTransitionsModal()">Manage Transitions</button>
            <button onclick="showZonesModal()">Manage Zones</button>
            <button onclick="showObjectsModal()">Manage Objects</button>
        </div>

        <h3>File Operations</h3>
        <div class="button-group">
            <button onclick="showImportModal()">Import JSON</button>
            <button onclick="exportMap()">Export JSON</button>
            <button onclick="downloadMap()">Download JSON</button>
            <button class="danger" onclick="clearMap()">Clear Map</button>
        </div>
    </div>

    <div id="main">
        <div id="toolbar">
            <span>Current Tool: <strong id="current-tool">Paint</strong></span>
            <span>|</span>
            <span>Selected Tile: <strong id="current-tile">floor</strong></span>
            <span>|</span>
            <span id="coordinates">x: 0, y: 0</span>
        </div>
        
        <div id="canvas-container">
            <canvas id="map-canvas"></canvas>
        </div>
    </div>

    <!-- Import Modal -->
    <div id="import-modal" class="modal">
        <div class="modal-content">
            <h2>Import Map JSON</h2>
            <textarea id="import-json" placeholder="Paste your map JSON here..." style="height: 400px; font-family: monospace;"></textarea>
            <div id="import-message"></div>
            <div class="modal-buttons">
                <button onclick="closeImportModal()">Cancel</button>
                <button onclick="importMap()">Import</button>
            </div>
        </div>
    </div>

    <!-- Export Modal -->
    <div id="export-modal" class="modal">
        <div class="modal-content">
            <h2>Export Map JSON</h2>
            <textarea id="export-json" readonly style="height: 400px; font-family: monospace;"></textarea>
            <div class="modal-buttons">
                <button onclick="copyToClipboard()">Copy to Clipboard</button>
                <button onclick="closeExportModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Door Configuration Modal -->
    <div id="door-config-modal" class="modal">
        <div class="modal-content">
            <h2>Configure Door</h2>
            <p class="info-text">Position: <strong id="door-config-pos"></strong></p>
            
            <label>Initially Open:</label>
            <select id="door-config-open">
                <option value="false">Closed</option>
                <option value="true">Open</option>
            </select>
            
            <label>Required Key (leave empty if no key required):</label>
            <select id="door-config-key">
                <option value="">None - No Key Required</option>
                <option value="crane">Crane Key</option>
                <option value="square">Square Key</option>
                <option value="diamond">Diamond Key</option>
                <option value="master">Master Key</option>
            </select>
            
            <label>Lock Hint (shown when player tries to open without key):</label>
            <input type="text" id="door-config-hint" placeholder="This door is locked. The lock has an engraving of a crane.">
            
            <div class="modal-buttons">
                <button onclick="saveDoorConfig()">Save</button>
                <button onclick="removeDoorConfig()">Remove Door Tile</button>
                <button onclick="closeDoorConfigModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Object Configuration Modal -->
    <div id="object-config-modal" class="modal">
        <div class="modal-content">
            <h2>Configure Object</h2>
            <p class="info-text">Position: <strong id="object-config-pos"></strong></p>
            
            <label>Object Type:</label>
            <select id="object-type">
                <option value="item">Item Pickup</option>
                <option value="npc">NPC</option>
                <option value="battle_trigger">Battle Trigger</option>
                <option value="event">Event Trigger</option>
                <option value="examine">Examine Point</option>
                <option value="cutscene">Cutscene Trigger</option>
            </select>
            
            <div id="object-config-fields">
                <!-- Dynamic fields will be added here based on object type -->
            </div>
            
            <div class="modal-buttons">
                <button onclick="saveObjectConfig()">Save</button>
                <button onclick="removeObjectConfig()">Remove Object</button>
                <button onclick="closeObjectConfigModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Objects List Modal -->
    <div id="objects-modal" class="modal">
        <div class="modal-content">
            <h2>Manage Objects</h2>
            <p class="info-text">Click on objects on the map to edit them, or use the list below.</p>
            <div id="objects-list"></div>
            <div class="modal-buttons">
                <button onclick="closeObjectsModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Transitions Modal -->
    <div id="transitions-modal" class="modal">
        <div class="modal-content">
            <h2>Manage Transitions</h2>
            <div id="transitions-list"></div>
            <h3>Add New Transition</h3>
            <label>Position X:</label>
            <input type="number" id="trans-x" value="0" min="0">
            <label>Position Y:</label>
            <input type="number" id="trans-y" value="0" min="0">
            <label>Type:</label>
            <select id="trans-type">
                <option value="stairs_up">Stairs Up</option>
                <option value="stairs_down">Stairs Down</option>
            </select>
            <label>Target Map:</label>
            <input type="text" id="trans-target-map" placeholder="facility_floor2">
            <label>Target Position X:</label>
            <input type="number" id="trans-target-x" value="0" min="0">
            <label>Target Position Y:</label>
            <input type="number" id="trans-target-y" value="0" min="0">
            <div class="modal-buttons">
                <button onclick="addTransition()">Add</button>
                <button onclick="closeTransitionsModal()">Close</button>
            </div>
        </div>
    </div>

    <!-- Zones Modal -->
    <div id="zones-modal" class="modal">
        <div class="modal-content">
            <h2>Manage Encounter Zones</h2>
            <div id="zones-list"></div>
            <h3>Add New Zone</h3>
            <label>Zone Name:</label>
            <input type="text" id="zone-name" placeholder="main_corridor">
            <label>X:</label>
            <input type="number" id="zone-x" value="0" min="0">
            <label>Y:</label>
            <input type="number" id="zone-y" value="0" min="0">
            <label>Width:</label>
            <input type="number" id="zone-width" value="5" min="1">
            <label>Height:</label>
            <input type="number" id="zone-height" value="5" min="1">
            <label>Encounter Rate (0.0-1.0):</label>
            <input type="number" id="zone-rate" value="0.05" min="0" max="1" step="0.01">
            <label>Possible Battles (comma-separated):</label>
            <input type="text" id="zone-battles" placeholder="battle_01_outbreak, battle_02_campsite">
            <div class="modal-buttons">
                <button onclick="addZone()">Add</button>
                <button onclick="closeZonesModal()">Close</button>
            </div>
        </div>
    </div>

    <script>
        const TILE_TYPES = {
            'wall': { color: '#333333', name: 'Wall' },
            'floor': { color: '#999999', name: 'Floor' },
            'door': { color: '#8B4513', name: 'Door' },
            'stairs_up': { color: '#6666CC', name: 'Stairs Up' },
            'stairs_down': { color: '#4444AA', name: 'Stairs Down' },
            'crate': { color: '#A0806A', name: 'Crate' },
            'sandbag': { color: '#8A8A6A', name: 'Sandbag' },
            'rubble': { color: '#666666', name: 'Rubble' },
            'water': { color: '#2244AA', name: 'Water' },
            'window': { color: '#6AB0FF', name: 'Window' }
        };

        const OBJECT_EMOJIS = {
            'item': 'üì¶',
            'npc': 'üë§',
            'battle_trigger': '‚öîÔ∏è',
            'event': '‚≠ê',
            'examine': 'üîç',
            'cutscene': 'üé¨'
        };

        let mapData = {
            id: 'new_map',
            name: 'New Map',
            width: 30,
            height: 20,
            tile_size: 32,
            spawn_point: { x: 2, y: 10 },
            tiles: [],
            transitions: [],
            doors: [],
            objects: [],  // New: array of interactable objects
            encounter_zones: []
        };

        let canvas, ctx;
        let currentTool = 'paint';
        let selectedTile = 'floor';
        let isDragging = false;
        let isInitialClick = false;
        let zoneStart = null;
        let currentDoorConfigPos = null;
        let currentObjectConfigPos = null;
        let currentObjectConfigIndex = -1;

        // Selection tool variables
        let selectionStart = null;
        let selectionEnd = null;
        let selectedTiles = null;  // Stored tile data
        let isMovingSelection = false;
        let selectionOffset = null;

        let lastMouseX = 0;
        let lastMouseY = 0;

        window.onload = function() {
            canvas = document.getElementById('map-canvas');
            ctx = canvas.getContext('2d');
            
            initializeTilePalette();
            initializeMap();
            setupEventListeners();
            render();
        };

        function initializeTilePalette() {
            const palette = document.getElementById('tile-palette');
            palette.innerHTML = '';
            
            for (const [type, data] of Object.entries(TILE_TYPES)) {
                const button = document.createElement('div');
                button.className = 'tile-button';
                if (type === selectedTile) button.classList.add('selected');
                button.innerHTML = `${data.name}<span class="color-preview" style="background: ${data.color}"></span>`;
                button.onclick = () => selectTile(type);
                palette.appendChild(button);
            }
        }

        function selectTile(type) {
            selectedTile = type;
            document.getElementById('current-tile').textContent = TILE_TYPES[type].name;
            
            document.querySelectorAll('.tile-button').forEach(btn => {
                btn.classList.remove('selected');
            });
            event.target.closest('.tile-button').classList.add('selected');
        }

        function setTool(tool) {
            currentTool = tool;
            const toolNames = {
                'paint': 'Paint',
                'fill': 'Fill',
                'spawn': 'Set Spawn',
                'object': 'Place Object',
                'zone': 'Add Zone',
                'select': 'Select & Move'
            };
            document.getElementById('current-tool').textContent = toolNames[tool];
            
            if (tool === 'zone') {
                zoneStart = null;
            }
        }

        function initializeMap() {
            mapData.tiles = [];
            for (let y = 0; y < mapData.height; y++) {
                const row = [];
                for (let x = 0; x < mapData.width; x++) {
                    row.push('wall');
                }
                mapData.tiles.push(row);
            }
            
            canvas.width = mapData.width * mapData.tile_size;
            canvas.height = mapData.height * mapData.tile_size;
        }

        function resizeMap() {
            const newWidth = parseInt(document.getElementById('map-width').value);
            const newHeight = parseInt(document.getElementById('map-height').value);
            const newTileSize = parseInt(document.getElementById('tile-size').value);
            
            mapData.id = document.getElementById('map-id').value;
            mapData.name = document.getElementById('map-name').value;
            mapData.tile_size = newTileSize;
            
            const oldTiles = mapData.tiles;
            mapData.tiles = [];
            
            for (let y = 0; y < newHeight; y++) {
                const row = [];
                for (let x = 0; x < newWidth; x++) {
                    if (y < oldTiles.length && x < oldTiles[y].length) {
                        row.push(oldTiles[y][x]);
                    } else {
                        row.push('wall');
                    }
                }
                mapData.tiles.push(row);
            }
            
            mapData.width = newWidth;
            mapData.height = newHeight;
            
            // Remove elements that are now out of bounds
            mapData.doors = mapData.doors.filter(door => {
                const x = door.position.x;
                const y = door.position.y;
                return x < newWidth && y < newHeight && mapData.tiles[y][x] === 'door';
            });
            
            mapData.objects = mapData.objects.filter(obj => {
                return obj.position.x < newWidth && obj.position.y < newHeight;
            });
            
            canvas.width = newWidth * newTileSize;
            canvas.height = newHeight * newTileSize;
            
            render();
        }

        function setupEventListeners() {
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', (e) => {
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                handleMouseMove(e);
            });
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('mouseleave', handleMouseUp);

            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && currentTool === 'select') {
                    cancelSelection();
                }
            });
            
            document.getElementById('map-id').addEventListener('input', (e) => mapData.id = e.target.value);
            document.getElementById('map-name').addEventListener('input', (e) => mapData.name = e.target.value);
            
            // Object type change handler
            document.getElementById('object-type').addEventListener('change', updateObjectConfigFields);
        }

        function handleMouseDown(e) {
            isInitialClick = true;
            isDragging = false;
            handleCanvasClick(e);
        }

        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / mapData.tile_size);
            const y = Math.floor((e.clientY - rect.top) / mapData.tile_size);
            
            document.getElementById('coordinates').textContent = `x: ${x}, y: ${y}`;
            
            if (isInitialClick && !isDragging) {
                isDragging = true;
                isInitialClick = false;
            }
            
            // Handle selection tool
            if (currentTool === 'select') {
                if (selectionStart && !isMovingSelection && isDragging) {
                    selectionEnd = { x, y };
                    render();
                } else if (isMovingSelection) {
                    // Just render to show ghost preview
                    render();
                }
                return; // Don't process paint logic
            }
            
            // Handle paint drag
            if (isDragging && currentTool === 'paint') {
                // Skip doors when dragging (only place on initial click)
                if (selectedTile !== 'door' && !isInitialClick) {
                    const oldTile = mapData.tiles[y][x];
                    mapData.tiles[y][x] = selectedTile;
                    
                    // Handle door removal if painting over a door
                    if (oldTile === 'door' && selectedTile !== 'door') {
                        removeDoorAt(x, y);
                    }
                    
                    render();
                }
            }
        }

        function handleMouseUp(e) {
            isDragging = false;
            isInitialClick = false;
        }

        function handleCanvasClick(e) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / mapData.tile_size);
            const y = Math.floor((e.clientY - rect.top) / mapData.tile_size);
            
            if (x < 0 || x >= mapData.width || y < 0 || y >= mapData.height) return;
            
            switch (currentTool) {
                case 'paint':
                    const oldTile = mapData.tiles[y][x];
                    
                    // Check if clicking on an existing door or object
                    if (!isDragging) {
                        if (oldTile === 'door') {
                            openDoorConfig(x, y);
                            return;
                        }
                        
                        const objIndex = findObjectAt(x, y);
                        if (objIndex >= 0) {
                            openObjectConfig(x, y, objIndex);
                            return;
                        }
                    }
                    
                    // Don't allow door placement during drag (only on initial click)
                    if (selectedTile === 'door' && !isInitialClick) {
                        return;
                    }
                    
                    mapData.tiles[y][x] = selectedTile;
                    
                    if (oldTile === 'door' && selectedTile !== 'door') {
                        removeDoorAt(x, y);
                    } else if (selectedTile === 'door' && oldTile !== 'door') {
                        ensureDoorConfig(x, y);
                        if (isInitialClick) {
                            openDoorConfig(x, y);
                        }
                    }
                    
                    render();
                    break;
            }
        }

        function handleSelectionClick(x, y) {
            if (isMovingSelection && selectedTiles) {
                // Place the selection at the new location
                placeSelection(x, y);
                isMovingSelection = false;
                selectedTiles = null;
                selectionStart = null;
                selectionEnd = null;
                render();
            } else if (selectionStart === null) {
                // Start selection
                selectionStart = { x, y };
                selectionEnd = { x, y };
            } else {
                // Complete selection
                selectionEnd = { x, y };
                captureSelection();
            }
        }

        function captureSelection() {
            if (!selectionStart || !selectionEnd) return;
            
            const minX = Math.min(selectionStart.x, selectionEnd.x);
            const maxX = Math.max(selectionStart.x, selectionEnd.x);
            const minY = Math.min(selectionStart.y, selectionEnd.y);
            const maxY = Math.max(selectionStart.y, selectionEnd.y);
            
            const width = maxX - minX + 1;
            const height = maxY - minY + 1;
            
            // Capture the tiles
            selectedTiles = {
                tiles: [],
                width: width,
                height: height,
                originX: minX,
                originY: minY
            };
            
            for (let y = minY; y <= maxY; y++) {
                const row = [];
                for (let x = minX; x <= maxX; x++) {
                    row.push(mapData.tiles[y][x]);
                }
                selectedTiles.tiles.push(row);
            }
            
            // Enter move mode
            isMovingSelection = true;
            console.log('Selection captured:', width, 'x', height, 'tiles');
        }

        function placeSelection(targetX, targetY) {
            if (!selectedTiles) return;
            
            const width = selectedTiles.width;
            const height = selectedTiles.height;
            
            // Check if placement is valid
            if (targetX + width > mapData.width || targetY + height > mapData.height) {
                alert('Selection would go out of bounds!');
                return;
            }
            
            // Clear original location (fill with floor)
            for (let y = selectionStart.y; y <= selectionEnd.y; y++) {
                for (let x = selectionStart.x; x <= selectionEnd.x; x++) {
                    if (y >= 0 && y < mapData.height && x >= 0 && x < mapData.width) {
                        mapData.tiles[y][x] = 'floor';
                    }
                }
            }
            
            // Place tiles at new location
            for (let dy = 0; dy < height; dy++) {
                for (let dx = 0; dx < width; dx++) {
                    const newY = targetY + dy;
                    const newX = targetX + dx;
                    if (newY >= 0 && newY < mapData.height && newX >= 0 && newX < mapData.width) {
                        mapData.tiles[newY][newX] = selectedTiles.tiles[dy][dx];
                    }
                }
            }
            
            console.log('Selection placed at', targetX, ',', targetY);
        }

        function cancelSelection() {
            selectionStart = null;
            selectionEnd = null;
            selectedTiles = null;
            isMovingSelection = false;
            render();
        }

        function findObjectAt(x, y) {
            for (let i = 0; i < mapData.objects.length; i++) {
                const obj = mapData.objects[i];
                if (obj.position.x === x && obj.position.y === y) {
                    return i;
                }
            }
            return -1;
        }

        // Door functions
        function ensureDoorConfig(x, y) {
            const exists = mapData.doors.some(door => 
                door.position.x === x && door.position.y === y
            );
            
            if (!exists) {
                mapData.doors.push({
                    position: { x, y },
                    is_open: false
                });
            }
        }

        function removeDoorAt(x, y) {
            mapData.doors = mapData.doors.filter(door => 
                !(door.position.x === x && door.position.y === y)
            );
        }

        function openDoorConfig(x, y) {
            currentDoorConfigPos = { x, y };
            
            const doorConfig = mapData.doors.find(door => 
                door.position.x === x && door.position.y === y
            );
            
            document.getElementById('door-config-pos').textContent = `(${x}, ${y})`;
            
            if (doorConfig) {
                document.getElementById('door-config-open').value = doorConfig.is_open ? 'true' : 'false';
                document.getElementById('door-config-key').value = doorConfig.required_key || '';
                document.getElementById('door-config-hint').value = doorConfig.lock_hint || '';
            } else {
                document.getElementById('door-config-open').value = 'false';
                document.getElementById('door-config-key').value = '';
                document.getElementById('door-config-hint').value = '';
            }
            
            document.getElementById('door-config-modal').style.display = 'flex';
        }

        function saveDoorConfig() {
            if (!currentDoorConfigPos) return;
            
            const x = currentDoorConfigPos.x;
            const y = currentDoorConfigPos.y;
            
            removeDoorAt(x, y);
            
            const doorConfig = {
                position: { x, y },
                is_open: document.getElementById('door-config-open').value === 'true'
            };
            
            const requiredKey = document.getElementById('door-config-key').value;
            if (requiredKey) {
                doorConfig.required_key = requiredKey;
                const customHint = document.getElementById('door-config-hint').value;
                doorConfig.lock_hint = customHint || 
                    `This door is locked. It requires the ${requiredKey} key.`;
            }
            
            mapData.doors.push(doorConfig);
            
            closeDoorConfigModal();
            render();
        }

        function removeDoorConfig() {
            if (!currentDoorConfigPos) return;
            
            mapData.tiles[currentDoorConfigPos.y][currentDoorConfigPos.x] = 'floor';
            removeDoorAt(currentDoorConfigPos.x, currentDoorConfigPos.y);
            
            closeDoorConfigModal();
            render();
        }

        function closeDoorConfigModal() {
            document.getElementById('door-config-modal').style.display = 'none';
            currentDoorConfigPos = null;
        }

        // Object configuration functions
        function openObjectConfig(x, y, index) {
            currentObjectConfigPos = { x, y };
            currentObjectConfigIndex = index;
            
            document.getElementById('object-config-pos').textContent = `(${x}, ${y})`;
            
            if (index >= 0) {
                // Editing existing object
                const obj = mapData.objects[index];
                document.getElementById('object-type').value = obj.type;
                updateObjectConfigFields();
                populateObjectFields(obj);
            } else {
                // New object
                document.getElementById('object-type').value = 'item';
                updateObjectConfigFields();
            }
            
            document.getElementById('object-config-modal').style.display = 'flex';
        }

        function updateObjectConfigFields() {
            const type = document.getElementById('object-type').value;
            const fieldsContainer = document.getElementById('object-config-fields');
            fieldsContainer.innerHTML = '';
            
            const commonFields = `
                <label>Object ID (unique identifier):</label>
                <input type="text" id="object-id" placeholder="item_001 or npc_guard">
            `;
            
            fieldsContainer.innerHTML = commonFields;
            
            switch(type) {
                case 'item':
                    fieldsContainer.innerHTML += `
                        <label>Item ID (from items.json):</label>
                        <input type="text" id="object-item-id" placeholder="key_crane, health_herb, etc.">
                        
                        <label>Amount (for stackable items):</label>
                        <input type="number" id="object-amount" value="1" min="1">
                        
                        <label>Examine Text (when player looks at it):</label>
                        <textarea id="object-examine" placeholder="There's a small key on the ground."></textarea>
                    `;
                    break;
                    
                case 'npc':
                    fieldsContainer.innerHTML += `
                        <label>NPC Name:</label>
                        <input type="text" id="object-npc-name" placeholder="Guard">
                        
                        <label>Dialogue Text:</label>
                        <textarea id="object-dialogue" placeholder="Hello there! Be careful ahead."></textarea>
                        
                        <label>Requires Item (optional - item_id needed to talk):</label>
                        <input type="text" id="object-requires" placeholder="key_master">
                    `;
                    break;
                    
                case 'battle_trigger':
                    fieldsContainer.innerHTML += `
                        <label>Battle ID:</label>
                        <input type="text" id="object-battle-id" placeholder="battle_01_outbreak">
                        
                        <label>One-Time Only:</label>
                        <select id="object-once">
                            <option value="true">Yes - Trigger once then remove</option>
                            <option value="false">No - Can trigger multiple times</option>
                        </select>
                    `;
                    break;
                    
                case 'event':
                    fieldsContainer.innerHTML += `
                        <label>Event Type:</label>
                        <select id="object-event-type">
                            <option value="message">Show Message</option>
                            <option value="give_item">Give Item</option>
                            <option value="spawn_enemies">Spawn Enemies</option>
                            <option value="unlock_door">Unlock Door</option>
                        </select>
                        
                        <label>Event Data (JSON format):</label>
                        <textarea id="object-event-data" placeholder='{"message": "You hear a strange noise..."}'></textarea>
                        
                        <label>One-Time Only:</label>
                        <select id="object-once">
                            <option value="true">Yes</option>
                            <option value="false">No</option>
                        </select>
                    `;
                    break;
                    
                case 'examine':
                    fieldsContainer.innerHTML += `
                        <label>Examine Text:</label>
                        <textarea id="object-examine" placeholder="It's an old painting on the wall."></textarea>
                        
                        <label>Detailed Description (on second examination):</label>
                        <textarea id="object-detail" placeholder="Looking closer, you notice a hidden compartment..."></textarea>
                    `;
                    break;
                case 'cutscene':
                    fieldsContainer.innerHTML += `
                        <label>Cutscene ID:</label>
                        <input type="text" id="object-cutscene-id" placeholder="intro_scene">
                        
                        <label>One-Time Only:</label>
                        <select id="object-once">
                            <option value="true">Yes - Play once then remove</option>
                            <option value="false">No - Can trigger multiple times</option>
                        </select>
                    `;
                    break;
            }
        }

        function populateObjectFields(obj) {
            document.getElementById('object-id').value = obj.id || '';
            
            switch(obj.type) {
                case 'cutscene':
                    if (document.getElementById('object-cutscene-id')) {
                        document.getElementById('object-cutscene-id').value = obj.cutscene_id || '';
                        document.getElementById('object-once').value = obj.once ? 'true' : 'false';
                    }
                    break;
                case 'item':
                    if (document.getElementById('object-item-id')) {
                        document.getElementById('object-item-id').value = obj.item_id || '';
                        document.getElementById('object-amount').value = obj.amount || 1;
                        document.getElementById('object-examine').value = obj.examine_text || '';
                    }
                    break;
                    
                case 'npc':
                    if (document.getElementById('object-npc-name')) {
                        document.getElementById('object-npc-name').value = obj.npc_name || '';
                        document.getElementById('object-dialogue').value = obj.dialogue || '';
                        document.getElementById('object-requires').value = obj.requires_item || '';
                    }
                    break;
                    
                case 'battle_trigger':
                    if (document.getElementById('object-battle-id')) {
                        document.getElementById('object-battle-id').value = obj.battle_id || '';
                        document.getElementById('object-once').value = obj.once ? 'true' : 'false';
                    }
                    break;
                    
                case 'event':
                    if (document.getElementById('object-event-type')) {
                        document.getElementById('object-event-type').value = obj.event_type || 'message';
                        document.getElementById('object-event-data').value = JSON.stringify(obj.event_data || {}, null, 2);
                        document.getElementById('object-once').value = obj.once ? 'true' : 'false';
                    }
                    break;
                    
                case 'examine':
                    if (document.getElementById('object-examine')) {
                        document.getElementById('object-examine').value = obj.examine_text || '';
                        document.getElementById('object-detail').value = obj.detail_text || '';
                    }
                    break;
            }
        }

        function saveObjectConfig() {
            if (!currentObjectConfigPos) return;
            
            const type = document.getElementById('object-type').value;
            const id = document.getElementById('object-id').value;
            
            if (!id) {
                alert('Object ID is required!');
                return;
            }
            
            const obj = {
                id: id,
                type: type,
                position: {
                    x: currentObjectConfigPos.x,
                    y: currentObjectConfigPos.y
                }
            };
            
            // Add type-specific data
            switch(type) {
                case 'item':
                    obj.item_id = document.getElementById('object-item-id').value;
                    obj.amount = parseInt(document.getElementById('object-amount').value) || 1;
                    obj.examine_text = document.getElementById('object-examine').value;
                    break;
                    
                case 'npc':
                    obj.npc_name = document.getElementById('object-npc-name').value;
                    obj.dialogue = document.getElementById('object-dialogue').value;
                    obj.requires_item = document.getElementById('object-requires').value;
                    break;
                    
                case 'battle_trigger':
                    obj.battle_id = document.getElementById('object-battle-id').value;
                    obj.once = document.getElementById('object-once').value === 'true';
                    break;
                    
                case 'event':
                    obj.event_type = document.getElementById('object-event-type').value;
                    try {
                        obj.event_data = JSON.parse(document.getElementById('object-event-data').value);
                    } catch (e) {
                        alert('Invalid JSON in event data!');
                        return;
                    }
                    obj.once = document.getElementById('object-once').value === 'true';
                    break;
                    
                case 'examine':
                    obj.examine_text = document.getElementById('object-examine').value;
                    obj.detail_text = document.getElementById('object-detail').value;
                    break;
                case 'cutscene':
                    obj.cutscene_id = document.getElementById('object-cutscene-id').value;
                    obj.once = document.getElementById('object-once').value === 'true';
                    break;
            }
            
            // Remove any existing object at this position
            mapData.objects = mapData.objects.filter((o, i) => 
                !(o.position.x === obj.position.x && o.position.y === obj.position.y)
            );
            
            // Add the object
            mapData.objects.push(obj);
            
            closeObjectConfigModal();
            render();
        }

        function removeObjectConfig() {
            if (currentObjectConfigIndex >= 0) {
                mapData.objects.splice(currentObjectConfigIndex, 1);
            } else if (currentObjectConfigPos) {
                mapData.objects = mapData.objects.filter(obj => 
                    !(obj.position.x === currentObjectConfigPos.x && 
                      obj.position.y === currentObjectConfigPos.y)
                );
            }
            
            closeObjectConfigModal();
            render();
        }

        function closeObjectConfigModal() {
            document.getElementById('object-config-modal').style.display = 'none';
            currentObjectConfigPos = null;
            currentObjectConfigIndex = -1;
        }

        // Objects list modal
        function showObjectsModal() {
            updateObjectsList();
            document.getElementById('objects-modal').style.display = 'flex';
        }

        function closeObjectsModal() {
            document.getElementById('objects-modal').style.display = 'none';
        }

        function updateObjectsList() {
            const list = document.getElementById('objects-list');
            list.innerHTML = '';
            
            if (mapData.objects.length === 0) {
                list.innerHTML = '<p class="info-text">No objects placed. Use the Place Object tool to add them.</p>';
                return;
            }
            
            mapData.objects.forEach((obj, index) => {
                const item = document.createElement('div');
                item.className = 'list-item';
                const emoji = OBJECT_EMOJIS[obj.type] || '‚ùì';
                item.innerHTML = `
                    <div class="list-item-content">
                        <strong>${emoji} ${obj.id}</strong> (${obj.type})<br>
                        <small>Position: (${obj.position.x}, ${obj.position.y})</small>
                    </div>
                    <button onclick="editObjectFromList(${index})">Edit</button>
                    <button onclick="removeObjectFromList(${index})">Remove</button>
                `;
                list.appendChild(item);
            });
        }

        function editObjectFromList(index) {
            const obj = mapData.objects[index];
            openObjectConfig(obj.position.x, obj.position.y, index);
        }

        function removeObjectFromList(index) {
            mapData.objects.splice(index, 1);
            updateObjectsList();
            render();
        }

        function floodFill(x, y, targetType, replacementType) {
            if (targetType === replacementType) return;
            if (mapData.tiles[y][x] !== targetType) return;
            
            const stack = [[x, y]];
            
            while (stack.length > 0) {
                const [cx, cy] = stack.pop();
                
                if (cx < 0 || cx >= mapData.width || cy < 0 || cy >= mapData.height) continue;
                if (mapData.tiles[cy][cx] !== targetType) continue;
                
                mapData.tiles[cy][cx] = replacementType;
                
                stack.push([cx + 1, cy]);
                stack.push([cx - 1, cy]);
                stack.push([cx, cy + 1]);
                stack.push([cx, cy - 1]);
            }
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw tiles
            for (let y = 0; y < mapData.height; y++) {
                for (let x = 0; x < mapData.width; x++) {
                    const tileType = mapData.tiles[y][x];
                    const color = TILE_TYPES[tileType]?.color || '#FF00FF';
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(
                        x * mapData.tile_size,
                        y * mapData.tile_size,
                        mapData.tile_size,
                        mapData.tile_size
                    );
                    
                    ctx.strokeStyle = '#1a1a1a';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(
                        x * mapData.tile_size,
                        y * mapData.tile_size,
                        mapData.tile_size,
                        mapData.tile_size
                    );
                    
                    // Draw lock on doors with keys
                    if (tileType === 'door') {
                        const doorConfig = mapData.doors.find(d => 
                            d.position.x === x && d.position.y === y
                        );
                        
                        if (doorConfig && doorConfig.required_key) {
                            ctx.fillStyle = '#FFD700';
                            ctx.font = 'bold 16px Arial';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            ctx.fillText('üîí', 
                                x * mapData.tile_size + mapData.tile_size / 2,
                                y * mapData.tile_size + mapData.tile_size / 2
                            );
                        }
                    }
                }
            }
            
            // Draw spawn point
            ctx.fillStyle = '#00FF00';
            ctx.beginPath();
            ctx.arc(
                mapData.spawn_point.x * mapData.tile_size + mapData.tile_size / 2,
                mapData.spawn_point.y * mapData.tile_size + mapData.tile_size / 2,
                mapData.tile_size / 4,
                0,
                Math.PI * 2
            );
            ctx.fill();
            
            // Draw objects
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            for (const obj of mapData.objects) {
                const emoji = OBJECT_EMOJIS[obj.type] || '‚ùì';
                const centerX = obj.position.x * mapData.tile_size + mapData.tile_size / 2;
                const centerY = obj.position.y * mapData.tile_size + mapData.tile_size / 2;
                
                // Draw background circle
                ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                ctx.beginPath();
                ctx.arc(centerX, centerY, mapData.tile_size * 0.4, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw emoji
                ctx.fillText(emoji, centerX, centerY);
            }
            
            // Draw encounter zones
            ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
            ctx.lineWidth = 2;
            for (const zone of mapData.encounter_zones) {
                ctx.strokeRect(
                    zone.rect.x * mapData.tile_size,
                    zone.rect.y * mapData.tile_size,
                    zone.rect.width * mapData.tile_size,
                    zone.rect.height * mapData.tile_size
                );
            }
            
            // DRAW SELECTION - This should be last to be on top
            if (currentTool === 'select' && selectionStart) {
                console.log('Drawing selection:', selectionStart, selectionEnd, isMovingSelection);
                
                if (isMovingSelection && selectedTiles) {
                    // Show ghost of selection being moved (follows mouse)
                    const rect = canvas.getBoundingClientRect();
                    const mouseX = Math.floor((lastMouseX - rect.left) / mapData.tile_size);
                    const mouseY = Math.floor((lastMouseY - rect.top) / mapData.tile_size);
                    
                    console.log('Drawing ghost at', mouseX, mouseY);
                    
                    // Draw the tiles themselves in ghost form
                    for (let dy = 0; dy < selectedTiles.height; dy++) {
                        for (let dx = 0; dx < selectedTiles.width; dx++) {
                            const tileType = selectedTiles.tiles[dy][dx];
                            const color = TILE_TYPES[tileType]?.color || '#FF00FF';
                            
                            ctx.fillStyle = color;
                            ctx.globalAlpha = 0.5;
                            ctx.fillRect(
                                (mouseX + dx) * mapData.tile_size,
                                (mouseY + dy) * mapData.tile_size,
                                mapData.tile_size,
                                mapData.tile_size
                            );
                            ctx.globalAlpha = 1.0;
                        }
                    }
                    
                    // Draw outline
                    ctx.strokeStyle = '#64C8FF';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(
                        mouseX * mapData.tile_size,
                        mouseY * mapData.tile_size,
                        selectedTiles.width * mapData.tile_size,
                        selectedTiles.height * mapData.tile_size
                    );
                } else if (selectionEnd) {
                    // Draw selection rectangle while selecting
                    const minX = Math.min(selectionStart.x, selectionEnd.x);
                    const maxX = Math.max(selectionStart.x, selectionEnd.x);
                    const minY = Math.min(selectionStart.y, selectionEnd.y);
                    const maxY = Math.max(selectionStart.y, selectionEnd.y);
                    
                    console.log('Drawing yellow selection:', minX, minY, 'to', maxX, maxY);
                    
                    // Fill with semi-transparent overlay
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                    ctx.fillRect(
                        minX * mapData.tile_size,
                        minY * mapData.tile_size,
                        (maxX - minX + 1) * mapData.tile_size,
                        (maxY - minY + 1) * mapData.tile_size
                    );
                    
                    // Draw border
                    ctx.strokeStyle = '#FFFF00';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([]);
                    ctx.strokeRect(
                        minX * mapData.tile_size,
                        minY * mapData.tile_size,
                        (maxX - minX + 1) * mapData.tile_size,
                        (maxY - minY + 1) * mapData.tile_size
                    );
                }
            }
        }

        function clearMap() {
            if (confirm('Clear the entire map? This cannot be undone.')) {
                initializeMap();
                mapData.transitions = [];
                mapData.doors = [];
                mapData.objects = [];
                mapData.encounter_zones = [];
                render();
            }
        }

        // Import/Export functions
        function showImportModal() {
            document.getElementById('import-modal').style.display = 'flex';
        }

        function closeImportModal() {
            document.getElementById('import-modal').style.display = 'none';
            document.getElementById('import-message').innerHTML = '';
        }

        function importMap() {
            const json = document.getElementById('import-json').value;
            const messageEl = document.getElementById('import-message');
            
            try {
                const imported = JSON.parse(json);
                
                if (!imported.tiles || !Array.isArray(imported.tiles)) {
                    throw new Error('Invalid map format: missing tiles array');
                }
                
                mapData = imported;
                
                document.getElementById('map-id').value = mapData.id || 'imported_map';
                document.getElementById('map-name').value = mapData.name || 'Imported Map';
                document.getElementById('map-width').value = mapData.width || mapData.tiles[0].length;
                document.getElementById('map-height').value = mapData.height || mapData.tiles.length;
                document.getElementById('tile-size').value = mapData.tile_size || 32;
                
                mapData.spawn_point = mapData.spawn_point || { x: 0, y: 0 };
                mapData.transitions = mapData.transitions || [];
                mapData.doors = mapData.doors || [];
                mapData.objects = mapData.objects || [];
                mapData.encounter_zones = mapData.encounter_zones || [];
                
                canvas.width = mapData.width * mapData.tile_size;
                canvas.height = mapData.height * mapData.tile_size;
                
                render();
                
                messageEl.innerHTML = '<span class="success">Map imported successfully!</span>';
                setTimeout(() => closeImportModal(), 1500);
            } catch (e) {
                messageEl.innerHTML = `<span class="error">Error: ${e.message}</span>`;
            }
        }

        function exportMap() {
            // Clean up before export
            mapData.doors = mapData.doors.filter(door => {
                const x = door.position.x;
                const y = door.position.y;
                return x >= 0 && x < mapData.width && 
                       y >= 0 && y < mapData.height && 
                       mapData.tiles[y][x] === 'door';
            });
            
            const json = JSON.stringify(mapData, null, 2);
            document.getElementById('export-json').value = json;
            document.getElementById('export-modal').style.display = 'flex';
        }

        function closeExportModal() {
            document.getElementById('export-modal').style.display = 'none';
        }

        function copyToClipboard() {
            const textarea = document.getElementById('export-json');
            textarea.select();
            document.execCommand('copy');
            alert('Copied to clipboard!');
        }

        function downloadMap() {
            mapData.doors = mapData.doors.filter(door => {
                const x = door.position.x;
                const y = door.position.y;
                return x >= 0 && x < mapData.width && 
                       y >= 0 && y < mapData.height && 
                       mapData.tiles[y][x] === 'door';
            });
            
            const json = JSON.stringify(mapData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${mapData.id}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Transitions management
        function showTransitionsModal() {
            updateTransitionsList();
            document.getElementById('transitions-modal').style.display = 'flex';
        }

        function closeTransitionsModal() {
            document.getElementById('transitions-modal').style.display = 'none';
        }

        function updateTransitionsList() {
            const list = document.getElementById('transitions-list');
            list.innerHTML = '';
            
            mapData.transitions.forEach((trans, index) => {
                const item = document.createElement('div');
                item.className = 'list-item';
                item.innerHTML = `
                    <span>${trans.type} at (${trans.position.x}, ${trans.position.y}) ‚Üí ${trans.target_map}</span>
                    <button onclick="removeTransition(${index})">Remove</button>
                `;
                list.appendChild(item);
            });
        }

        function addTransition() {
            const transition = {
                position: {
                    x: parseInt(document.getElementById('trans-x').value),
                    y: parseInt(document.getElementById('trans-y').value)
                },
                type: document.getElementById('trans-type').value,
                target_map: document.getElementById('trans-target-map').value,
                target_position: {
                    x: parseInt(document.getElementById('trans-target-x').value),
                    y: parseInt(document.getElementById('trans-target-y').value)
                }
            };
            
            mapData.transitions.push(transition);
            updateTransitionsList();
            render();
        }

        function removeTransition(index) {
            mapData.transitions.splice(index, 1);
            updateTransitionsList();
            render();
        }

        // Zones management
        function showZonesModal() {
            updateZonesList();
            document.getElementById('zones-modal').style.display = 'flex';
        }

        function closeZonesModal() {
            document.getElementById('zones-modal').style.display = 'none';
        }

        function updateZonesList() {
            const list = document.getElementById('zones-list');
            list.innerHTML = '';
            
            mapData.encounter_zones.forEach((zone, index) => {
                const item = document.createElement('div');
                item.className = 'list-item';
                item.innerHTML = `
                    <span>${zone.name}: (${zone.rect.x}, ${zone.rect.y}) ${zone.rect.width}x${zone.rect.height}</span>
                    <button onclick="removeZone(${index})">Remove</button>
                `;
                list.appendChild(item);
            });
        }

        function addZone() {
            const battles = document.getElementById('zone-battles').value
                .split(',')
                .map(b => b.trim())
                .filter(b => b.length > 0);
            
            const zone = {
                name: document.getElementById('zone-name').value,
                rect: {
                    x: parseInt(document.getElementById('zone-x').value),
                    y: parseInt(document.getElementById('zone-y').value),
                    width: parseInt(document.getElementById('zone-width').value),
                    height: parseInt(document.getElementById('zone-height').value)
                },
                encounter_rate: parseFloat(document.getElementById('zone-rate').value),
                possible_battles: battles
            };
            
            mapData.encounter_zones.push(zone);
            updateZonesList();
            render();
        }

        function removeZone(index) {
            mapData.encounter_zones.splice(index, 1);
            updateZonesList();
            render();
        }
    </script>
</body>
</html>
